var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// package.json
var package_exports = {};
__export(package_exports, {
  default: () => package_default,
  dependencies: () => dependencies,
  devDependencies: () => devDependencies,
  files: () => files,
  gitHead: () => gitHead,
  license: () => license,
  main: () => main,
  module: () => module,
  name: () => name,
  peerDependencies: () => peerDependencies,
  publishConfig: () => publishConfig,
  scripts: () => scripts,
  type: () => type,
  types: () => types,
  version: () => version
});
var name, version, files, type, main, module, types, license, publishConfig, peerDependencies, dependencies, devDependencies, scripts, gitHead, package_default;
var init_package = __esm({
  "package.json"() {
    name = "@particle-network/provider";
    version = "1.2.0";
    files = [
      "es",
      "lib",
      "LICENSE"
    ];
    type = "module";
    main = "lib/index.js";
    module = "es/index.js";
    types = "lib/types/index.d.ts";
    license = "Apache-2.0";
    publishConfig = {
      access: "public"
    };
    peerDependencies = {
      "@particle-network/auth": "*"
    };
    dependencies = {
      "@particle-network/chains": "*",
      axios: "^1.3.6",
      uuid: "^8.3.2"
    };
    devDependencies = {
      "@particle-network/auth": "*",
      "@types/uuid": "^8.3.4",
      "ts-loader": "^9.3.1",
      "webpack-cli": "^4.10.0"
    };
    scripts = {
      package: `shx echo '{ "type": "commonjs" }' > lib/package.json`,
      build: "yarn clean && node ./esBuild.js && tsc --emitDeclarationOnly -p tsconfig.json && yarn package",
      clean: "shx rm -rf lib/* && shx rm -rf es/*",
      "build:min.js": "webpack",
      version: "yarn build"
    };
    gitHead = "cc999e430ebfb1dd821783f7cf099ddd51f3495a";
    package_default = {
      name,
      version,
      files,
      type,
      main,
      module,
      types,
      license,
      publishConfig,
      peerDependencies,
      dependencies,
      devDependencies,
      scripts,
      gitHead
    };
  }
});

// src/provider.ts
import { intToHex as intToHex2, rpcUrl } from "@particle-network/auth";
import { v4 as uuidv4 } from "uuid";

// src/auth-adapter.ts
import { addHexPrefix, intToHex, isNullish } from "@particle-network/auth";
import { chains } from "@particle-network/chains";
import { Buffer as Buffer2 } from "buffer";

// src/types.ts
import { EventEmitter } from "events";
var ProviderError = class extends Error {
  constructor(code, message, data) {
    super(message);
    this.code = code;
    this.message = message;
    this.data = data;
    this.code = code;
    this.message = message;
    this.data = data;
  }
  static userRejectedRequest() {
    return new ProviderError(4001, "The user rejected the request");
  }
  static userCancelOperation() {
    return new ProviderError(4011, "The user cancel the operation");
  }
  static unauthorized() {
    return new ProviderError(4100, "The requested method and/or account has not been authorized by the user");
  }
  static unsupportedMethod() {
    return new ProviderError(4200, "The Provider does not support the requested method");
  }
  static unsupportedChain() {
    return new ProviderError(4201, "The Provider does not support the chain");
  }
  static disconnected() {
    return new ProviderError(4900, "The Provider is disconnected from all chains");
  }
  static chainDisconnected() {
    return new ProviderError(4901, "The Provider is not connected to the requested chain");
  }
  static paramsError() {
    return new ProviderError(8002, "Param error, see doc for more info");
  }
};
var IEvents = class {
};
var IJsonRpcConnection = class extends IEvents {
  constructor() {
    super(...arguments);
    this.events = new EventEmitter();
  }
  on(event, listener) {
    this.events.on(event, listener);
    return this;
  }
  once(event, listener) {
    this.events.once(event, listener);
    return this;
  }
  off(event, listener) {
    this.events.off(event, listener);
    return this;
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
    return this;
  }
};
var IJsonRpcProvider = class extends IEvents {
  constructor() {
    super(...arguments);
    this.events = new EventEmitter();
  }
  on(event, listener) {
    this.events.on(event, listener);
    return this;
  }
  once(event, listener) {
    this.events.once(event, listener);
    return this;
  }
  off(event, listener) {
    this.events.off(event, listener);
    return this;
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
    return this;
  }
};
var notSupportMethods = ["eth_signTransaction", "eth_sign", "eth_sendRawTransaction"];
var signerMethods = [
  "eth_requestAccounts",
  "eth_accounts",
  "eth_chainId",
  "eth_sendTransaction",
  "eth_signTypedData",
  "eth_signTypedData_v1",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "personal_sign",
  "wallet_switchEthereumChain",
  "wallet_addEthereumChain",
  "wallet_watchAsset"
];
var particleSignerMethods = [
  "personal_sign_uniq",
  "eth_signTypedData_v4_uniq"
];

// src/auth-adapter.ts
var AuthEVMAdapter = class {
  constructor(auth) {
    this.auth = auth;
    this.auth = auth;
  }
  request(request) {
    return __async(this, null, function* () {
      if (request.method === "eth_requestAccounts" || request.method === "eth_accounts") {
        let wallet = this.auth.getWallet();
        if (wallet) {
          return [wallet.public_address];
        }
        yield this.auth.login();
        wallet = this.auth.getWallet();
        if (wallet) {
          return [wallet.public_address];
        } else {
          throw new Error("Create wallet failed");
        }
      } else if (request.method === "eth_chainId") {
        return intToHex(this.auth.getChainId());
      } else if (request.method === "eth_sendTransaction") {
        if (request.params && request.params instanceof Array && request.params[0]) {
          const txData = request.params[0];
          if (isNullish(txData.type)) {
            if (chains.isChainSupportEIP1559(this.auth.getChain())) {
              txData.type = "0x2";
            } else {
              txData.type = "0x0";
            }
          }
          if (isNullish(txData.chainId)) {
            txData.chainId = intToHex(this.auth.getChainId());
          }
          if (isNullish(txData.nonce)) {
            txData.nonce = "0x0";
          }
          if (isNullish(txData.data)) {
            txData.data = "0x";
          }
          return this.auth.sendTransaction(this.legacyToString(request.params[0]));
        } else {
          return Promise.reject(ProviderError.paramsError());
        }
      } else if (request.method === "eth_signTypedData_v3" || request.method === "eth_signTypedData_v4" || request.method === "eth_signTypedData_v4_uniq") {
        if (request.params && request.params instanceof Array && request.params.length >= 2) {
          let typedData = request.params[1];
          if (typeof typedData === "string" && !typedData.startsWith("0x")) {
            typedData = addHexPrefix(Buffer2.from(typedData).toString("hex"));
          }
          return this.auth.sign(request.method, this.legacyToString(typedData));
        } else {
          return Promise.reject(ProviderError.paramsError());
        }
      } else if (request.method === "eth_signTypedData" || request.method === "eth_signTypedData_v1") {
        if (request.params && request.params instanceof Array && request.params[0]) {
          let typedData = request.params[0];
          if (typeof typedData === "string" && !typedData.startsWith("0x")) {
            typedData = addHexPrefix(Buffer2.from(typedData).toString("hex"));
          }
          return this.auth.sign(request.method, this.legacyToString(typedData));
        } else {
          return Promise.reject(ProviderError.paramsError());
        }
      } else if (request.method === "personal_sign" || request.method === "personal_sign_uniq") {
        if (request.params && request.params instanceof Array && request.params[0]) {
          return this.auth.sign(request.method, this.legacyToString(request.params[0]));
        } else {
          return Promise.reject(ProviderError.paramsError());
        }
      } else if (request.method === "wallet_switchEthereumChain") {
        if (request.params && request.params instanceof Array && request.params[0] && request.params[0].chainId) {
          const chainId = Number(request.params[0].chainId);
          const chain = chains.getEVMChainInfoById(chainId);
          if (chain) {
            yield this.auth.switchChain(chain);
            return Promise.resolve(null);
          }
          return Promise.reject(ProviderError.unsupportedChain());
        } else {
          return Promise.reject(ProviderError.paramsError());
        }
      } else {
        return Promise.reject(ProviderError.unsupportedMethod());
      }
    });
  }
  legacyToString(params) {
    let message;
    if (typeof params === "number") {
      message = addHexPrefix(params.toString(16));
    } else if (typeof params === "string") {
      if (params.toString().startsWith("0x")) {
        message = params;
      } else {
        message = addHexPrefix(Buffer2.from(params).toString("hex"));
      }
    } else {
      message = addHexPrefix(Buffer2.from(JSON.stringify(params)).toString("hex"));
    }
    return message;
  }
};

// src/connection.ts
import { isHttpUrl } from "@particle-network/auth";
import axios from "axios";
var HttpConnection = class extends IJsonRpcConnection {
  constructor(config) {
    super();
    this.config = config;
    this.registering = false;
    if (!isHttpUrl(config.url)) {
      throw new Error(`Provided URL is not compatible with HTTP connection: ${config.url}`);
    }
    this.config = config;
  }
  get connected() {
    return typeof this.api !== "undefined";
  }
  get connecting() {
    return this.registering;
  }
  open() {
    return __async(this, null, function* () {
      this.api = yield this.register();
    });
  }
  close() {
    return __async(this, null, function* () {
      this.onClose();
    });
  }
  send(request) {
    return __async(this, null, function* () {
      if (typeof this.api === "undefined") {
        this.api = yield this.register();
      }
      return this.api.post("/", request).then((res) => res.data);
    });
  }
  register() {
    return __async(this, null, function* () {
      const connectConfig = this.config;
      if (!isHttpUrl(connectConfig.url)) {
        throw new Error(`Provided URL is not compatible with HTTP connection: ${connectConfig.url}`);
      }
      if (this.registering) {
        return new Promise((resolve, reject) => {
          this.events.once("open", () => {
            if (typeof this.api === "undefined") {
              return reject(new Error("HTTP connection is missing or invalid"));
            }
            resolve(this.api);
          });
        });
      }
      this.registering = true;
      const api = axios.create({
        baseURL: connectConfig.url,
        timeout: 3e4,
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json"
        }
      });
      api.interceptors.request.use(
        function(config) {
          var _a, _b;
          if (!config.params) {
            config.params = {};
          }
          config.params.chainId = (_b = (_a = config.data) == null ? void 0 : _a.chainId) != null ? _b : connectConfig.chainId();
          config.params.projectUuid = connectConfig.authentication.projectId;
          config.params.projectKey = connectConfig.authentication.clientKey;
          return config;
        },
        (error) => Promise.reject(error)
      );
      this.onOpen(api);
      return api;
    });
  }
  onOpen(api) {
    this.api = api;
    this.registering = false;
    this.events.emit("open");
  }
  onClose() {
    this.api = void 0;
    this.events.emit("close");
  }
};

// src/utils.ts
function getVersion() {
  const packages = (init_package(), __toCommonJS(package_exports));
  return `web_${packages.version}`;
}

// src/provider.ts
var ParticleProvider = class extends IJsonRpcProvider {
  constructor(auth) {
    super();
    this.auth = auth;
    this.isParticleNetwork = true;
    this.auth = auth;
    this.connection = this.setConnection();
    this.authAdapter = new AuthEVMAdapter(this.auth);
    this.auth.on("chainChanged", (chain) => {
      if (chain.name !== "Solana") {
        this.emit("chainChanged", intToHex2(chain.id));
      }
    });
    if (typeof window !== "undefined" && window.particle) {
      window.particle.particleProvider = this;
    }
  }
  get version() {
    return getVersion();
  }
  setConnection() {
    return new HttpConnection({
      url: `${rpcUrl()}/evm-chain`,
      basicCredentials: this.auth.basicCredentials(),
      chainId: () => this.auth.getChainId(),
      authentication: this.auth.config
    });
  }
  emit(eventName, ...args) {
    return this.events.emit(eventName, ...args);
  }
  disconnect() {
    return __async(this, null, function* () {
      return this.auth.logout();
    });
  }
  enable() {
    return __async(this, null, function* () {
      return this.request({
        method: "eth_requestAccounts"
      });
    });
  }
  request(request) {
    return __async(this, null, function* () {
      var _a, _b;
      if (!request.method || notSupportMethods.includes(request.method)) {
        return Promise.reject(ProviderError.unsupportedMethod());
      }
      if (!this.connection.connected) {
        yield this.open();
      }
      const rpcRequest = {
        chainId: Number(this.auth.getChainId()),
        id: (_a = request.id) != null ? _a : uuidv4(),
        jsonrpc: (_b = request.jsonrpc) != null ? _b : "2.0",
        method: request.method,
        params: request.params
      };
      if (signerMethods.includes(request.method) || particleSignerMethods.includes(request.method)) {
        return this.authAdapter.request(request);
      } else {
        return this.requestStrict(rpcRequest);
      }
    });
  }
  requestStrict(request) {
    return __async(this, null, function* () {
      return this.connection.send(request).then((output) => {
        if (output.error) {
          return Promise.reject(output.error);
        } else {
          return Promise.resolve(output.result);
        }
      });
    });
  }
  open() {
    return __async(this, null, function* () {
      yield this.connection.open();
      this.connection.on("close", () => this.emit("disconnect"));
      this.emit("connect", {
        chainId: intToHex2(this.auth.getChainId())
      });
    });
  }
  close() {
    return __async(this, null, function* () {
      yield this.connection.close();
    });
  }
};

// src/delegate-provider.ts
import { rpcUrl as rpcUrl2 } from "@particle-network/auth";
import { v4 as uuidv42 } from "uuid";
var ParticleDelegateProvider = class extends IJsonRpcProvider {
  constructor(auth, signerProvider) {
    super();
    this.auth = auth;
    this.signerProvider = signerProvider;
    this.isParticleDelegateProvider = true;
    this.connection = this.setConnection();
    this.listenEvent();
  }
  listenEvent() {
    const event = this.events;
    this.signerProvider.on("connect", (result) => event.emit("connect", result));
    this.signerProvider.on("disconnect", (result) => event.emit("disconnect", result));
    this.signerProvider.on("message", (result) => event.emit("message", result));
    this.signerProvider.on("chainChanged", (result) => event.emit("chainChanged", result));
    this.signerProvider.on("accountsChanged", (result) => event.emit("accountsChanged", result));
  }
  setConnection() {
    return new HttpConnection({
      url: `${rpcUrl2()}/evm-chain`,
      basicCredentials: this.auth.basicCredentials(),
      chainId: () => {
        var _a;
        return (_a = this.chainId) != null ? _a : this.auth.getChainId();
      },
      authentication: this.auth.config
    });
  }
  disconnect() {
    return __async(this, null, function* () {
      const provider = this.signerProvider;
      if (provider.disconnect && typeof provider.disconnect === "function") {
        try {
          yield provider.disconnect();
        } catch (e) {
        }
      }
    });
  }
  enable() {
    return __async(this, null, function* () {
      const provider = this.signerProvider;
      let result;
      if (provider.enable && typeof provider.enable === "function") {
        try {
          result = yield provider.enable();
        } catch (e) {
          result = yield this.request({
            method: "eth_requestAccounts"
          });
        }
      }
      return result;
    });
  }
  request(request) {
    return __async(this, null, function* () {
      var _a, _b;
      if (!request.method || notSupportMethods.includes(request.method)) {
        return Promise.reject(ProviderError.unsupportedMethod());
      }
      if (!this.connection.connected) {
        yield this.open();
      }
      const rpcRequest = {
        id: (_a = request.id) != null ? _a : uuidv42(),
        jsonrpc: (_b = request.jsonrpc) != null ? _b : "2.0",
        method: request.method,
        params: request.params
      };
      if (signerMethods.includes(rpcRequest.method) || this.isParticleSignerMethod(rpcRequest.method)) {
        return yield this.signerProvider.request(rpcRequest);
      } else {
        try {
          this.chainId = Number(yield this.signerProvider.request({ method: "eth_chainId" }));
        } catch (error) {
          this.chainId = Number(this.auth.getChainId());
        }
        const particlePpcRequest = __spreadProps(__spreadValues({}, rpcRequest), { chainId: this.chainId });
        return yield this.requestStrict(particlePpcRequest);
      }
    });
  }
  isParticleSignerMethod(method) {
    return this.signerProvider.isParticleNetwork && particleSignerMethods.includes(method);
  }
  requestStrict(request) {
    return __async(this, null, function* () {
      return this.connection.send(request).then((output) => {
        if (output.error) {
          return Promise.reject(output.error);
        } else {
          return Promise.resolve(output.result);
        }
      });
    });
  }
  open() {
    return __async(this, null, function* () {
      yield this.connection.open();
    });
  }
};
export {
  ParticleDelegateProvider,
  ParticleProvider
};
//# sourceMappingURL=index.js.map
